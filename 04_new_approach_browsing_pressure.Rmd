---
title: "new_approach"
author: "anne"
date: "9 januar 2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
load("processdata/browse9bro_dist.rda")
browse9bro_dist$beitetrykkr <- as.integer(browse9bro_dist$beitetrykkr)
browse9bro_dist$bt100 <- browse9bro_dist$beitetrykkr/100
```


#### Modelling spatial autocorrelation (https://onlinelibrary.wiley.com/doi/full/10.1111/j.2007.0906-7590.05171.x)
Change the projection and make coordinates and a spatial point data frame to make a shapefile
<<<<<<< HEAD

```{r}
unite(browse9bro_dist, UTMmerge, c(UTM_OV_33, UTM_SN_33), remove = FALSE)
duplicated(browse9bro_dist$UTMmerge)
```


=======
>>>>>>> 7b5fc0f76fb0ad535f364c49c83ad170e6abc86e
```{r}

library(sp)
library(rgdal)

crs <- CRS("+proj=utm +zone=33 +ellps=GRS80 +units=m +no_defs")
coords <- cbind(browse9bro_dist$UTM_OV_33, browse9bro_dist$UTM_SN_33)
data_spdf <- SpatialPointsDataFrame(coords, browse9bro_dist, proj4string = crs)
plot(data_spdf)
writeOGR(data_spdf, dsn = "output", layer = "spdf", driver = "ESRI Shapefile")

```


```{r}

library(spdep)
# ?autocov_dist

# prepare neighbour lists for spatial autocorrelation analysis
# nb.list <- dnearneigh(as.matrix(browse9bro_dist[,c("UTM_OV_33", "UTM_SN_33")]), 0, 6)
# nb.weights <- nb2listw(nb.list)

# Make a matrix of coordinates - use when chunk above was not run
# coords <- as.matrix(cbind(browse9bro_dist$UTM_OV_33, browse9bro_dist$UTM_SN_33))

# compute the autocovariate based on the above distance and weight
<<<<<<< HEAD
ac <- autocov_dist(browse9bro_dist$bt100, coords, nbs = 5000, type="inverse", zero.policy = TRUE)
=======
ac <- autocov_dist(browse9bro_dist$bt100, coords, nbs = 300000, type="inverse", zero.policy = TRUE)
>>>>>>> 7b5fc0f76fb0ad535f364c49c83ad170e6abc86e
browse9bro_dist$ac <- ac


# now run a linear model with the autocovariate as additional explanatory variable:
# fm <- lm(snouter1.1 ~ rain + djungle + ac, data=snouter.df)
# summary(fm)

```




#### First part of a hurdle/ zeroinlf model to account for zero inflation
```{r}
m1bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant + helling + HOH + tretetthet + skogkategori*distvei1,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m2bin <- glm(factor(beitetrykkr > 0) ~ distvei1,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m3bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m4bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m5bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m6bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m7bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m8bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant + helling,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m9bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant + helling + HOH,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

m10bin <- glm(factor(beitetrykkr > 0) ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant + helling + HOH + tretetthet,
            family = binomial(link = "cloglog"),
            data = browse9bro_dist)

```


```{r}
AIC(m1bin, m2bin, m3bin, m4bin, m5bin, m6bin, m7bin, m8bin, m9bin, m10bin)
```
```{r}
summary(m1bin)

plot(allEffects(m1bin))

```




#### Instead of having the second part of a hurdle or zeroinfl model, use a beta regression, because we have percentage data (use a subset of the dataset with only response values above 0) - need to account for spatial autocorrelation
```{r}

m1beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + region + kant + helling + HOH + tretetthet + skogkategori*distvei1,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m1abeta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac + kant + helling + HOH + tretetthet + skogkategori*distvei1,
            data = browse9bro_dist,
            subset = beitetrykkr > 0) # nbs (in ac) = 5000

m2beta <- betareg(bt100 ~ distvei1 + ac,
            data = browse9bro_dist,
            subset = beitetrykkr > 0) 

m3beta <- betareg(bt100 ~ distvei1 + disthus+ ac,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m3abeta <- betareg(bt100 ~ disthus+ ac,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m4beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + ac,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m5beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m6beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac + kant,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m7beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac + kant + helling,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m8beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac + kant + helling + HOH,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)

m9beta <- betareg(bt100 ~ distvei1 + disthus + skogkategori + treartgruppe + ac + kant + helling + HOH + tretetthet,
            data = browse9bro_dist,
            subset = beitetrykkr > 0)




```



```{r}
<<<<<<< HEAD
AIC(m1beta, m1abeta, m2beta, m3beta, m4beta, m5beta, m6beta, m7beta, m8beta, m9beta)
AIC(m3beta, m3abeta)
AIC(m1beta, m1abeta)
=======
AIC(m1beta, m2beta, m3beta, m4beta, m5beta, m6beta, m7beta, m8beta, m9beta, m10beta, m11beta, m11abeta)
AIC(m1beta, m1abeta, m1bbeta, m1cbeta, m1dbeta, m1ebeta, m1fbeta, m1gbeta, m1hbeta)
AIC(m1beta, m1hbeta, m1gbeta) # g (150000) og h (300000) har samme AIC 
>>>>>>> 7b5fc0f76fb0ad535f364c49c83ad170e6abc86e
```


```{r}
summary(m3beta)
summary(m1abeta)
vcov(m1abeta)

lrtest(m3beta, m1abeta)
waldtest(m3beta, m1abeta)

plot(m1beta)
plot(m1abeta)

visreg(m1abeta)


<<<<<<< HEAD
predbetareg <- cbind(
predict(m1abeta, type = "response"), # fitted means of response
predict(m1abeta, type = "link"), # corresponding linear predictor
predict(m1abeta, type = "variance"), # fitted variances of response
predict(m1abeta, type = "quantile", at = c(0.25, 0.5, 0.75)) # r fitted quantile(s) of the response distribution
)
colnames(predbetareg) <- c("response", "link", "variance", "qu0.25", "qu0.5", "qu0.75")

head(predbetareg)
=======
summary(m1gbeta)

plot(m1beta)
plot(m1gbeta)
>>>>>>> 7b5fc0f76fb0ad535f364c49c83ad170e6abc86e



```




























