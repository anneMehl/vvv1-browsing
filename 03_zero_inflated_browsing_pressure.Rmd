---
title: "hurdle"
author: "anne"
date: "3 desember 2018"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}

load("processdata/browse_9.rda")
# load("processdata/browse9pos.rda")

```



## Christer's approach

```{r}
m1 <- glm(cbind(bt.binom, beitetrykk) ~ distvei1 + disthus + landsdel + skogkategori + kant + helling + hohkatb + treartgruppe, family = "binomial", data = browse9) # not the right variables in the response, should be: "beitet, totaltundersokt"

summary(m1)
plot(m1)
```




## Hurdle model (Also: two-way model) and two-way model "old school" (Zuur 2009, chapter: Zero-truncated and zero-inflated models for count data)
For count data, helps with excess zeros and overdispersion

##### Hurdle model, using hurdle() from pscl package
```{r}

f1 <- formula(beitetrykk ~ distvei1 + disthus + landsdel + skogkategori + kant + helling + hohkatb + treartgruppe)
f2 <- formula(beitetrykk ~ distvei1 + disthus + landsdel + skogkategori + kant + helling + hohkatb + treartgruppe | distvei1 + disthus + landsdel + skogkategori + kant + helling + hohkatb + treartgruppe) # This is the same as in f1: The first part before the | is for the binomial model, the second part is for the poission or negative binomial model, and it is possible to use different explanatories but when only one part is specified as in f1, both models are run with the same explanatories. Both parts are run after each other in the hurdle function. And as I understood it from the book, there is no need to use a binomial reponse, they use a normal count response in their example as well.

H1a <- hurdle(f1, dist = "poisson", link = "logit", 
              data = browse9)  # Error in solve.default(as.matrix(fit_zero$hessian)) : system is computationally singular: reciprocal condition number = 1.25111e-20
H1b <- hurdle(f1, dist = "negbin", link = "logit", 
              data = browse9)  # NaNs producedNaNs produced - Error in solve.default(as.matrix(fit_zero$hessian)) : system is computationally singular: reciprocal condition number = 1.25111e-20

```

##### Two-way model "old school" with first running a binomial glm with a binomial respose (browsing yes/no), then running a poisson glm 
```{r}

B1 <- glm(bt.binom ~ distvei1 + disthus + landsdel + skogkategori + treartgruppe + kant + helling + hohkatb, data = browse9,
            family = "binomial")
P1 <- glm(beitetrykk ~ distvei1 + disthus + landsdel + skogkategori + treartgruppe + kant + helling + hohkatb, data = browse9pos,
            family = "poisson") 
P2 <- glm(beitetrykk ~ distvei1 + landsdel + skogkategori + treartgruppe + kant + helling + hohkatb, data = browse9pos,
            family = "poisson") # Here I took out the distance to house, because it was not significant. However, when comparing both AIC, the models barely differ.



summary(B1)
summary(P1)
summary(P2)
plot(P1)
plot(P2)
AIC(P1, P2)

```




```{r}
mod1 <- glm(beitetrykk ~ distvei1 + disthus + landsdel + skogkategori + kant + helling + hohkatb + treartgruppe, family = "poisson", data = browse9)

mu <- predict(mod1, type = "response") # predict expected mean count
exp <- sum(dpois(x = 0, lambda = mu)) # sum the probabilities of a 0 count for each mean
exp # predicted number of 0's
sum(browse9$beitetrykk < 1, na.rm = TRUE)  # observed number of 0's

```

```{r}

cor((as.matrix(browse9[browse9$beitetrykk,c("distvei1", "disthus", "helling")])),
      use = "complete")
```

























